(define (make-closure body env)
  (list 'closure body env))
(define (closure? c)
  (eq? (car c) 'closure))
(define closure-args caadr)
(define closure-exp cadadr)
(define closure-env caddr)

(define (make-delayed body env)
  (list 'delayed body env))
(define (delayed? x)
  (and (pair? x) (eq? (car x) 'delayed)))
(define delayed-body cadr)
(define delayed-env caddr)

(define (my-eval exp env)
  (let ((result (cond ((number? exp) exp)
		      ((symbol? exp) (my-lookup exp env))
		      ((eq? (car exp) 'quote) (cadr exp))
		      ((eq? (car exp) 'cond) (eval-cond (cdr exp) env))
		      ((eq? (car exp) 'lambda)
		       (list 'closure (cdr exp) env))
		      (else (my-apply (my-eval (car exp) env)
				      (cdr exp)
				      env)))))
    (if (delayed? result)
	(my-eval (delayed-body result) (delayed-env result))
	result)))

(define (my-apply proc args env)
  (cond ((primitive? proc) (apply-primitive proc (my-evlist args env)))
	((closure? proc)
	 (my-eval (closure-exp proc)
		  (extend-env (my-bind (closure-args proc)
				       args
				       env)
			      (closure-env proc))))
	(else (error "Unknown function type"))))

(define (eval-cond cases env)
  (cond ((null? cases) '())
	((eq? (caar cases) 'else) (my-eval (cadar cases) env))
	((my-eval (caar cases) env) (my-eval (cadar cases) env))
	(else (eval-cond (cdr cases) env))))

(define (my-evlist l env)
  (map (lambda (exp) (my-eval exp env)) l))

(define (my-bind args vals env)
  (cond ((null? args)
	 (if (null? vals)
	     '()
	     (error "Too many args")))
	((symbol? args) (list (cons args (my-evlist vals env))))
	((null? vals) (error "Too few args"))
	((and (pair? (car args))
	      (eq? (caar args) 'name))
	 (cons (cons (cadar args) (make-delayed (car vals) env))
	       (my-bind (cdr args) (cdr vals) env)))
	(else (cons (cons (car args) (my-eval (car vals) env))
		    (my-bind (cdr args) (cdr vals) env)))))

(define extend-env cons)

(define (my-lookup symbol env)
  (define (lookup-iter e)
    (if (null? e)
	'()
	(if (eq? (caar e) symbol)
	    (car e)
	    (lookup-iter (cdr e)))))
  (if (null? env)
      (error "Unknown variable")
      ((lambda (result)
	 (if (null? result)
	     (my-lookup symbol (cdr env))
	     (cdr result)))
       (lookup-iter (car env)))))

(define (primitive? x)
  (or (eq? x +)
      (eq? x /)
      (eq? x eq?)
      (eq? x cons)
      (eq? x car)
      (eq? x cdr)))

(define apply-primitive apply)

(define e0
  (list (list (cons '+ +)
	      (cons '/ /)
	      (cons 'eq? eq?)
	      (cons 'cons cons)
	      (cons 'car car)
	      (cons 'cdr cdr))))
